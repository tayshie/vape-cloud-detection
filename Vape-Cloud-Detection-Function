def detect_vape_cloud(frame, sensitivity=50):
    """
    Process the frame to detect a vape cloud.
    
    Idea:
      - Convert the frame to HSV color space.
      - Create a mask to detect “cloud-like” regions (here we look for light regions).
      - Use morphological filtering to reduce noise.
      - Find contours and pick the largest.
      - Draw a bounding box and return the area of that box.
    
    Parameters:
        frame (np.ndarray): The input image frame (BGR format).
        sensitivity (int): A value (0-255) controlling mask thresholding.
    
    Returns:
        processed_frame (np.ndarray): The frame with an overlay (if cloud is detected).
        measurement (float): The area (in pixel units) of the detected vape cloud.
    """
    # Convert to HSV – vape clouds are usually whitish so we threshold on high brightness.
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    # Define HSV thresholds for “white” vapor (the range can be tuned)
    lower_white = np.array([0, 0, sensitivity])
    upper_white = np.array([180, 55, 255])
    mask = cv2.inRange(hsv, lower_white, upper_white)

    # Apply morphological opening (erosion followed by dilation) to remove small noise
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5,5))
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)

    # Find contours in the mask. Use RETR_EXTERNAL to get only the outer contours.
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    measurement = 0  # Default measurement if nothing is found

    if contours:
        # Choose the largest contour assuming it is the vape cloud.
        largest_contour = max(contours, key=cv2.contourArea)
        # Get bounding box around the contour.
        x, y, w, h = cv2.boundingRect(largest_contour)
        measurement = w * h  # Relative area in pixels.
        # Draw a rectangle on the original frame (in green)
        cv2.rectangle(frame, (x, y), (x+w, y+h), (0, 255, 0), 2)
        # Optionally, overlay the measurement as text:
        cv2.putText(frame, f"Size: {measurement:,} px", (x, y-10),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0,255,0), 2)
    return frame, measurement
